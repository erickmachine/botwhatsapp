const { Client, LocalAuth, MessageMedia } = require("whatsapp-web.js")
const qrcode = require("qrcode-terminal")
const fs = require("fs")
const path = require("path")
const fetch = require("node-fetch")
const puppeteer = require("puppeteer")
const { exec } = require("child_process")
const https = require("https")
const http = require("http")

// Configura√ß√µes do bot
const BOT_CONFIG = {
  adminNumber: "5592999652961", // Seu n√∫mero
  secondAdminNumber: "5592985231368", // Segundo n√∫mero autorizado
  prefix: "/",
  botName: "GroupBot",
  version: "1.0.0",
}

const client = new Client({
  authStrategy: new LocalAuth({
    clientId: "whatsapp-bot",
    dataPath: "./auth_data",
  }),
  puppeteer: {
    headless: true,
    args: [
      "--no-sandbox",
      "--disable-setuid-sandbox",
      "--disable-dev-shm-usage",
      "--disable-web-security",
      "--no-first-run",
    ],
    timeout: 15000, // Reduzido para 15 segundos
    executablePath: undefined,
  },
})

// Dados dos grupos e usu√°rios
let groupData = {}
let userData = {}

// Carregar dados salvos
function loadData() {
  try {
    if (fs.existsSync("./data/groups.json")) {
      groupData = JSON.parse(fs.readFileSync("./data/groups.json", "utf8"))
    }
    if (fs.existsSync("./data/users.json")) {
      userData = JSON.parse(fs.readFileSync("./data/users.json", "utf8"))
    }
  } catch (error) {
    console.log("Erro ao carregar dados:", error)
  }
}

// Salvar dados
function saveData() {
  try {
    if (!fs.existsSync("./data")) {
      fs.mkdirSync("./data")
    }
    fs.writeFileSync("./data/groups.json", JSON.stringify(groupData, null, 2))
    fs.writeFileSync("./data/users.json", JSON.stringify(userData, null, 2))
  } catch (error) {
    console.log("Erro ao salvar dados:", error)
  }
}

// Verificar se √© admin
function isAdmin(userId) {
  return userId.includes(BOT_CONFIG.adminNumber) || userId.includes(BOT_CONFIG.secondAdminNumber)
}

// Verificar se o usu√°rio √© admin do grupo
async function isGroupAdmin(chat, userId) {
  if (!chat.isGroup) return false

  try {
    const participants = chat.participants

    // Normalizar o userId para compara√ß√£o
    const normalizeNumber = (number) => {
      if (!number) return ""
      return number.toString().replace(/\D/g, "").slice(-11)
    }

    const normalizedUserId = normalizeNumber(userId)

    const userParticipant = participants.find((p) => {
      let participantNumber = ""

      if (p.id.user) {
        participantNumber = normalizeNumber(p.id.user)
      } else if (p.id._serialized) {
        participantNumber = normalizeNumber(p.id._serialized.split("@")[0])
      }

      return participantNumber === normalizedUserId
    })

    return userParticipant ? userParticipant.isAdmin : false
  } catch (error) {
    console.log(`[DEBUG] Erro ao verificar admin do grupo: ${error.message}`)
    return false
  }
}

// Limpar dados de autentica√ß√£o de forma segura
function safeCleanAuthData() {
  try {
    if (fs.existsSync("./auth_data")) {
      console.log("üßπ Limpando dados de autentica√ß√£o...")

      // Tentar limpeza normal primeiro
      try {
        fs.rmSync("./auth_data", { recursive: true, force: true })
        console.log("‚úÖ Dados limpos com sucesso!")
      } catch (error) {
        if (error.code === "EBUSY") {
          console.log("‚ö†Ô∏è Arquivos em uso, tentando limpeza alternativa...")

          // Limpeza alternativa para Windows
          try {
            const { execSync } = require("child_process")
            if (process.platform === "win32") {
              execSync("taskkill /f /im chrome.exe /t", { stdio: "ignore" })
              setTimeout(() => {
                try {
                  fs.rmSync("./auth_data", { recursive: true, force: true })
                  console.log("‚úÖ Dados limpos ap√≥s finalizar Chrome!")
                } catch (e) {
                  console.log("‚ö†Ô∏è Alguns arquivos n√£o puderam ser removidos, mas o bot continuar√° funcionando")
                }
              }, 2000)
            }
          } catch (e) {
            console.log("‚ö†Ô∏è Limpeza parcial realizada, reinicie manualmente se necess√°rio")
          }
        } else {
          throw error
        }
      }
    }
  } catch (error) {
    console.log("‚ö†Ô∏è Erro na limpeza:", error.message)
  }
}

let qrRetries = 0
const maxQrRetries = 3
let qrTimeout = null
let isReconnecting = false // Prevenir m√∫ltiplas reconex√µes

client.on("qr", (qr) => {
  console.clear()
  console.log("üöÄ WhatsApp Bot - QR Code Gerado!")
  console.log("=".repeat(50))
  console.log("üì± Escaneie o QR Code abaixo RAPIDAMENTE:")
  console.log("")

  qrcode.generate(qr, { small: true })

  console.log("")
  console.log("üìã Instru√ß√µes:")
  console.log("1. Abra WhatsApp no celular")
  console.log("2. V√° em Dispositivos Conectados")
  console.log("3. Toque em Conectar Dispositivo")
  console.log("4. Escaneie o c√≥digo acima")
  console.log("")
  console.log(`üîÑ Tentativa: ${qrRetries + 1}/${maxQrRetries}`)
  console.log("‚ö†Ô∏è QR Code expira em 15 segundos!")

  if (qrTimeout) clearTimeout(qrTimeout)

  qrTimeout = setTimeout(() => {
    if (qrRetries < maxQrRetries - 1) {
      qrRetries++
      console.log(`‚ö†Ô∏è QR Code expirou! Gerando novo... (${qrRetries}/${maxQrRetries})`)
    } else {
      console.log("‚ùå Muitas tentativas. Limpando dados e reiniciando...")
      safeCleanAuthData() // Usar limpeza segura
      setTimeout(() => process.exit(1), 3000)
    }
  }, 15000)
})

client.on("authenticated", () => {
  console.log("‚úÖ Autenticado com sucesso!")
  console.log("üîÑ Conectando ao WhatsApp...")
  if (qrTimeout) clearTimeout(qrTimeout)
})

client.on("auth_failure", (msg) => {
  console.error("‚ùå Falha na autentica√ß√£o:", msg)
  safeCleanAuthData() // Usar limpeza segura

  console.log("üîÑ Reiniciando em 5 segundos...")
  setTimeout(() => {
    process.exit(1)
  }, 5000)
})

client.on("ready", () => {
  console.clear()
  console.log("üéâ BOT CONECTADO COM SUCESSO!")
  console.log("=".repeat(50))
  console.log(`üì± Bot: ${BOT_CONFIG.botName} v${BOT_CONFIG.version}`)
  console.log(`üë§ Admin Principal: +${BOT_CONFIG.adminNumber}`)
  console.log(`üë§ Admin Secund√°rio: +${BOT_CONFIG.secondAdminNumber}`)
  console.log(`‚è∞ Conectado em: ${new Date().toLocaleString("pt-BR")}`)
  console.log("")
  console.log("üîß Status: Online e funcionando!")
  console.log("üìã Use /menu em qualquer grupo para ver comandos")
  console.log("‚ö†Ô∏è Lembre-se: Voc√™ deve estar no grupo para o bot funcionar!")
  console.log("")

  if (qrTimeout) clearTimeout(qrTimeout)
  qrRetries = 0
  loadData()
})

client.on("disconnected", (reason) => {
  if (isReconnecting) return // Prevenir m√∫ltiplas reconex√µes

  console.log("‚ö†Ô∏è Bot desconectado:", reason)
  isReconnecting = true

  if (client.pupPage) {
    try {
      client.pupPage.close()
    } catch (e) {}
  }

  if (client.pupBrowser) {
    try {
      client.pupBrowser.close()
    } catch (e) {}
  }

  // Limpar dados apenas em casos espec√≠ficos
  if (reason === "LOGOUT" || reason === "CONFLICT" || reason === "UNPAIRED") {
    setTimeout(() => {
      safeCleanAuthData() // Usar limpeza segura com delay
    }, 2000)
  }

  console.log("üîÑ Reiniciando em 5 segundos...")
  setTimeout(() => {
    process.exit(1)
  }, 5000)
})

// Processar mensagens
client.on("message", async (message) => {
  try {
    const chat = await message.getChat()
    const contact = await message.getContact()
    const userId = contact.id.user
    const messageBody = message.body.toLowerCase().trim()

    if (!chat.isGroup) {
      console.log(`[DEBUG] Mensagem privada ignorada de: +${userId}`)
      return // N√£o responder em conversas privadas
    }

    console.log(`[DEBUG] Processando mensagem no grupo: ${chat.name}`)

    // Processar comandos
    if (messageBody.startsWith(BOT_CONFIG.prefix)) {
      await processCommand(message, chat, contact, messageBody)
    }

    // Salvar dados periodicamente
    saveData()
  } catch (error) {
    console.log("Erro ao processar mensagem:", error)
  }
})

// Processar comandos
async function processCommand(message, chat, contact, messageBody) {
  const args = messageBody.slice(BOT_CONFIG.prefix.length).split(" ")
  const command = args[0]
  const userId = contact.id.user

  if (!chat.isGroup) {
    console.log(`[DEBUG] Tentativa de comando em conversa privada bloqueada: +${userId}`)
    return
  }

  console.log(`[DEBUG] ‚úÖ Executando comando: ${command} no grupo: ${chat.name} por: +${userId}`)

  const adminOnlyCommands = [
    "ban",
    "kick",
    "add",
    "promote",
    "demote",
    "grupo",
    "tagall",
    "todos",
    "tiktok",
    "tt",
    "musica",
    "youtube",
    "yt",
    "limpar",
    "warn",
    "unwarn",
    "mute",
    "unmute",
    "antilink",
    "welcome",
    "goodbye",
    "autoreply",
    "encurtar",
  ]

  if (adminOnlyCommands.includes(command)) {
    const isUserGroupAdmin = await isGroupAdmin(chat, userId)
    if (!isUserGroupAdmin) {
      return await message.reply("‚ùå Apenas administradores do grupo podem usar este comando!")
    }
  }

  switch (command) {
    case "menu":
      await handleMenu(message, args[1])
      break

    case "ban":
    case "kick":
      await handleKick(message, chat)
      break
    case "add":
      await handleAdd(message, chat, args)
      break
    case "promote":
      await handlePromote(message, chat)
      break
    case "demote":
      await handleDemote(message, chat)
      break
    case "grupo":
      await handleGroupSettings(message, chat, args)
      break
    case "link":
      await handleGroupLink(message, chat)
      break
    case "tagall":
    case "todos":
      await handleTagAll(message, chat)
      break
    case "limpar":
      await handleClearMessages(message, chat, args)
      break
    case "warn":
      await handleWarn(message, chat)
      break
    case "unwarn":
      await handleUnwarn(message, chat)
      break
    case "mute":
      await handleMute(message, chat, args)
      break
    case "unmute":
      await handleUnmute(message, chat)
      break
    case "antilink":
      await handleAntiLink(message, chat, args)
      break
    case "welcome":
      await handleWelcome(message, chat, args)
      break
    case "goodbye":
      await handleGoodbye(message, chat, args)
      break
    case "autoreply":
      await handleAutoReply(message, chat, args)
      break
    case "encurtar":
      await handleShortenUrl(message, args)
      break

    case "info":
      await handleInfo(message)
      break
    case "perfil":
      await handleProfile(message)
      break
    case "grupo-info":
      await handleGroupInfo(message, chat)
      break
    case "status":
      await handleStatus(message)
      break
    case "ping":
      await handlePing(message)
      break
    case "uptime":
      await handleUptime(message)
      break

    case "dado":
      await handleDice(message)
      break
    case "moeda":
      await handleCoin(message)
      break
    case "par":
      await handleEvenOdd(message, args)
      break
    case "quiz":
      await handleQuiz(message)
      break
    case "8ball":
      await handle8Ball(message, args)
      break
    case "sorteio":
      await handleRaffle(message, args)
      break
    case "pedrapapeltesoura":
    case "ppt":
      await handleRockPaperScissors(message, args)
      break

    case "clima":
      await handleWeather(message, args)
      break
    case "calc":
      await handleCalculator(message, args)
      break
    case "lembrete":
      await handleReminder(message, args)
      break
    case "cep":
      await handleCEP(message, args)
      break
    case "cpf":
      await handleCPF(message, args)
      break
    case "cnpj":
      await handleCNPJ(message, args)
      break
    case "qrcode":
      await handleQRCode(message, args)
      break
    case "translate":
    case "traduzir":
      await handleTranslate(message, args)
      break

    case "tiktok":
    case "tt":
      await downloadTikTok(args[1], message)
      break
    case "musica":
    case "youtube":
    case "yt":
      await downloadMusic(args.slice(1).join(" "), message)
      break

    // Comandos de Figurinhas (Menu 7)
    case "sticker":
    case "fig":
      await handleSticker(message)
      break
    case "toimg":
      await handleStickerToImage(message)
      break

    default:
      if (command) {
        await message.reply("‚ùå Comando n√£o encontrado. Use */menu* para ver os comandos dispon√≠veis.")
      }
      break
  }
}

async function handleMenu(message, menuNumber) {
  let menuText = ""

  switch (menuNumber) {
    case "1":
      menuText = `
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ  üîß *ADMIN PANEL* üëë  ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

‚îå‚îÄ üë• *GERENCIAMENTO DE MEMBROS*
‚îú‚îÄ */ban* - üö´ Remove membro
‚îú‚îÄ */add [n√∫mero]* - ‚ûï Adiciona membro  
‚îú‚îÄ */promote* - ‚¨ÜÔ∏è Promove a admin
‚îú‚îÄ */demote* - ‚¨áÔ∏è Remove admin
‚îú‚îÄ */warn* - ‚ö†Ô∏è Advertir membro
‚îú‚îÄ */unwarn* - ‚úÖ Remove advert√™ncia
‚îú‚îÄ */mute [tempo]* - üîá Silenciar membro
‚îî‚îÄ */unmute* - üîä Remover sil√™ncio

‚îå‚îÄ ‚öôÔ∏è *CONFIGURA√á√ïES DO GRUPO*
‚îú‚îÄ */grupo abrir/fechar* - üîìüîí Controle do grupo
‚îú‚îÄ */link* - üîó Link de convite
‚îú‚îÄ */tagall* - üì¢ Marcar todos
‚îú‚îÄ */limpar [quantidade]* - üßπ Limpar mensagens
‚îú‚îÄ */antilink on/off* - üõ°Ô∏è Anti-link autom√°tico
‚îú‚îÄ */welcome [mensagem]* - üëã Mensagem de boas-vindas
‚îú‚îÄ */goodbye [mensagem]* - üëã Mensagem de despedida
‚îî‚îÄ */autoreply [palavra] [resposta]* - ü§ñ Resposta autom√°tica

‚îå‚îÄ üì• *DOWNLOADS PREMIUM*
‚îú‚îÄ */tiktok [link]* - üé¨ Download TikTok
‚îî‚îÄ */musica [nome/link]* - üéµ Download YouTube

‚ö†Ô∏è *Apenas ADMINISTRADORES podem usar*
      `
      break

    case "2":
      menuText = `
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ üìä *INFORMA√á√ïES* ‚ÑπÔ∏è   ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

‚îå‚îÄ ü§ñ *SOBRE O BOT*
‚îú‚îÄ */info* - üì± Informa√ß√µes completas
‚îú‚îÄ */status* - üìä Status do sistema
‚îú‚îÄ */ping* - üèì Lat√™ncia do bot
‚îî‚îÄ */uptime* - ‚è∞ Tempo online

‚îå‚îÄ üë§ *PERFIL & GRUPO*
‚îú‚îÄ */perfil* - üÜî Seu perfil detalhado
‚îî‚îÄ */grupo-info* - üë• Info do grupo atual

‚ú® *Informa√ß√µes em tempo real*
üìà *Dados precisos e atualizados*
üîç *Estat√≠sticas completas*
      `
      break

    case "3":
      menuText = `
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ  üéÆ *JOGOS & FUN* üéØ  ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

‚îå‚îÄ üé≤ *JOGOS DE SORTE*
‚îú‚îÄ */dado* - üé≤ Rola dado de 6 faces
‚îú‚îÄ */moeda* - ü™ô Cara ou coroa
‚îú‚îÄ */par [n√∫mero]* - üî¢ Par ou √≠mpar
‚îú‚îÄ */8ball [pergunta]* - üé± Bola m√°gica
‚îî‚îÄ */sorteio [op√ß√µes]* - üé∞ Sorteio aleat√≥rio

‚îå‚îÄ üéØ *JOGOS INTERATIVOS*
‚îú‚îÄ */quiz* - üß© Quiz de conhecimento
‚îî‚îÄ */ppt [pedra/papel/tesoura]* - ‚úÇÔ∏è Jokenp√¥

üèÜ *Divers√£o garantida para o grupo!*
üéä *Jogos simples e interativos*
‚ö° *Entretenimento instant√¢neo*
      `
      break

    case "4":
      menuText = `
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ üõ†Ô∏è *UTILIDADES* ‚ö°    ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

‚îå‚îÄ üåê *FERRAMENTAS WEB*
‚îú‚îÄ */clima [cidade]* - üå§Ô∏è Previs√£o do tempo
‚îú‚îÄ */calc [opera√ß√£o]* - üßÆ Calculadora
‚îú‚îÄ */encurtar [url]* - üîó Encurtar links
‚îú‚îÄ */qrcode [texto]* - üì± Gerar QR Code
‚îî‚îÄ */traduzir [texto]* - üåç Tradutor

‚îå‚îÄ üìã *CONSULTAS BRASIL*
‚îú‚îÄ */cep [c√≥digo]* - üìÆ Consultar CEP
‚îú‚îÄ */cpf [n√∫mero]* - üÜî Validar CPF
‚îî‚îÄ */cnpj [n√∫mero]* - üè¢ Validar CNPJ

‚îå‚îÄ ‚è∞ *PRODUTIVIDADE*
‚îî‚îÄ */lembrete [tempo] [texto]* - ‚è∞ Lembretes

üöÄ *Ferramentas pr√°ticas do dia a dia*
‚ö° *Respostas instant√¢neas e precisas*
üéØ *Tudo que voc√™ precisa em um lugar*
      `
      break

    case "7":
      menuText = `
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ üé® *FIGURINHAS* ‚ú®   ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

‚îå‚îÄ üì± *CRIA√á√ÉO DE STICKERS*
‚îú‚îÄ */sticker* - üé≠ Criar figurinha
‚îú‚îÄ */fig* - üé® Alias r√°pido
‚îî‚îÄ */toimg* - üñºÔ∏è Converter para imagem

‚ú® *RECURSOS AVAN√áADOS:*
üîÑ Convers√£o autom√°tica de qualidade
üìê Redimensionamento inteligente  
‚ö° Cria√ß√£o instant√¢nea
üéØ Interface super f√°cil
üñºÔ∏è Suporte a m√∫ltiplos formatos

üé® *Crie stickers incr√≠veis facilmente!*
      `
      break

    default:
      menuText = `
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ    ü§ñ *${BOT_CONFIG.botName}* ‚ú®     ‚îÇ
‚îÇ      *BOT PREMIUM* üöÄ        ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

üéØ *MENUS DISPON√çVEIS:*

‚îå‚îÄ üîß */menu 1* - Admin Panel (üëë Admins Only)
‚îú‚îÄ üìä */menu 2* - Informa√ß√µes & Status  
‚îú‚îÄ üéÆ */menu 3* - Jogos & Divers√£o
‚îú‚îÄ üõ†Ô∏è */menu 4* - Utilidades & Ferramentas
‚îî‚îÄ üé® */menu 7* - Figurinhas & Stickers

‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ   ‚ö° *STATUS ATUAL*   ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
üü¢ *Online* | üì± *v${BOT_CONFIG.version}*
üëë *Admins:* +${BOT_CONFIG.adminNumber}
üëë *Co-Admin:* +${BOT_CONFIG.secondAdminNumber}
‚ö° *Comandos:* 40+ dispon√≠veis
üéØ *Grupos Ativos:* Funcionando perfeitamente

üíé *O bot mais completo do WhatsApp!*
      `
      break
  }

  await message.reply(menuText)
}

// Comandos de Grupo
async function handleKick(message, chat) {
  if (!chat.isGroup) {
    return await message.reply("‚ùå Este comando s√≥ funciona em grupos!")
  }

  const quotedMessage = await message.getQuotedMessage()
  if (!quotedMessage) {
    return await message.reply("‚ùå Responda a mensagem de quem deseja remover!")
  }

  try {
    const contact = await quotedMessage.getContact()
    await chat.removeParticipants([contact.id._serialized])
    await message.reply(`‚úÖ @${contact.id.user} foi removido do grupo!`, null, {
      mentions: [contact],
    })
  } catch (error) {
    await message.reply("‚ùå Erro ao remover participante. Verifique se o bot √© admin!")
  }
}

async function handleAdd(message, chat, args) {
  if (!chat.isGroup) {
    return await message.reply("‚ùå Este comando s√≥ funciona em grupos!")
  }

  if (!args[1]) {
    return await message.reply("‚ùå Digite o n√∫mero para adicionar!\nExemplo: */add 5511999999999*")
  }

  try {
    const number = args[1].replace(/[^\d]/g, "")
    await chat.addParticipants([`${number}@c.us`])
    await message.reply(`‚úÖ N√∫mero +${number} foi adicionado ao grupo!`)
  } catch (error) {
    await message.reply("‚ùå Erro ao adicionar participante. Verifique o n√∫mero e se o bot √© admin!")
  }
}

async function handlePromote(message, chat) {
  if (!chat.isGroup) {
    return await message.reply("‚ùå Este comando s√≥ funciona em grupos!")
  }

  const quotedMessage = await message.getQuotedMessage()
  if (!quotedMessage) {
    return await message.reply("‚ùå Responda a mensagem de quem deseja promover!")
  }

  try {
    const contact = await quotedMessage.getContact()
    await chat.promoteParticipants([contact.id._serialized])
    await message.reply(`‚úÖ @${contact.id.user} foi promovido a admin!`, null, {
      mentions: [contact],
    })
  } catch (error) {
    await message.reply("‚ùå Erro ao promover participante! Verifique se o bot √© admin!")
  }
}

async function handleDemote(message, chat) {
  if (!chat.isGroup) {
    return await message.reply("‚ùå Este comando s√≥ funciona em grupos!")
  }

  const quotedMessage = await message.getQuotedMessage()
  if (!quotedMessage) {
    return await message.reply("‚ùå Responda a mensagem de quem deseja rebaixar!")
  }

  try {
    const contact = await quotedMessage.getContact()
    await chat.demoteParticipants([contact.id._serialized])
    await message.reply(`‚úÖ @${contact.id.user} foi rebaixado!`, null, {
      mentions: [contact],
    })
  } catch (error) {
    await message.reply("‚ùå Erro ao rebaixar participante! Verifique se o bot √© admin!")
  }
}

async function handleGroupSettings(message, chat, args) {
  if (!chat.isGroup) {
    return await message.reply("‚ùå Este comando s√≥ funciona em grupos!")
  }

  const action = args[1]

  try {
    if (action === "fechar") {
      await chat.setMessagesAdminsOnly(true)
      await message.reply("üîí Grupo fechado! Apenas admins podem enviar mensagens.")
    } else if (action === "abrir") {
      await chat.setMessagesAdminsOnly(false)
      await message.reply("üîì Grupo aberto! Todos podem enviar mensagens.")
    } else {
      await message.reply("‚ùå Use: */grupo abrir* ou */grupo fechar*")
    }
  } catch (error) {
    await message.reply("‚ùå Erro ao alterar configura√ß√µes do grupo! Verifique se o bot √© admin!")
  }
}

async function handleGroupLink(message, chat) {
  if (!chat.isGroup) {
    return await message.reply("‚ùå Este comando s√≥ funciona em grupos!")
  }

  try {
    const inviteCode = await chat.getInviteCode()
    await message.reply(`üîó *Link do Grupo:*\nhttps://chat.whatsapp.com/${inviteCode}`)
  } catch (error) {
    await message.reply("‚ùå Erro ao obter link do grupo! Verifique se o bot √© admin!")
  }
}

async function handleTagAll(message, chat) {
  if (!chat.isGroup) {
    return await message.reply("‚ùå Este comando s√≥ funciona em grupos!")
  }

  try {
    const participants = chat.participants
    const mentions = participants.map((p) => p.id._serialized)
    const mentionText = participants.map((p) => `@${p.id.user}`).join(" ")

    await message.reply(`üì¢ *Aten√ß√£o todos!*\n\n${mentionText}`, null, {
      mentions: mentions,
    })
  } catch (error) {
    await message.reply("‚ùå Erro ao marcar participantes!")
  }
}

async function handleClearMessages(message, chat, args) {
  const amount = Number.parseInt(args[1]) || 10
  await message.reply(
    `üßπ *Limpeza de Mensagens*\n\n‚ö†Ô∏è Fun√ß√£o em desenvolvimento.\nQuantidade solicitada: ${amount} mensagens`,
  )
}

async function handleWarn(message, chat) {
  if (!message.hasQuotedMsg) {
    return await message.reply("‚ùå Responda a mensagem do usu√°rio que deseja advertir!")
  }
  await message.reply(
    "‚ö†Ô∏è *Usu√°rio Advertido*\n\n‚úÖ Advert√™ncia aplicada com sucesso!\nüìä Sistema de advert√™ncias ativo.",
  )
}

async function handleUnwarn(message, chat) {
  if (!message.hasQuotedMsg) {
    return await message.reply("‚ùå Responda a mensagem do usu√°rio para remover advert√™ncia!")
  }
  await message.reply("‚úÖ *Advert√™ncia Removida*\n\nüîÑ Advert√™ncia removida com sucesso!")
}

async function handleMute(message, chat, args) {
  if (!message.hasQuotedMsg) {
    return await message.reply("‚ùå Responda a mensagem do usu√°rio que deseja silenciar!")
  }
  const time = args[1] || "10m"
  await message.reply(
    `üîá *Usu√°rio Silenciado*\n\n‚è∞ Tempo: ${time}\n‚úÖ Usu√°rio n√£o poder√° enviar mensagens temporariamente.`,
  )
}

async function handleUnmute(message, chat) {
  if (!message.hasQuotedMsg) {
    return await message.reply("‚ùå Responda a mensagem do usu√°rio para remover sil√™ncio!")
  }
  await message.reply("üîä *Sil√™ncio Removido*\n\n‚úÖ Usu√°rio pode enviar mensagens novamente!")
}

async function handleAntiLink(message, chat, args) {
  const action = args[1]?.toLowerCase()
  if (action === "on") {
    await message.reply(
      "üõ°Ô∏è *Anti-Link Ativado*\n\n‚úÖ Links ser√£o automaticamente removidos!\n‚ö†Ô∏è Apenas admins podem enviar links.",
    )
  } else if (action === "off") {
    await message.reply("üîì *Anti-Link Desativado*\n\n‚úÖ Links liberados para todos os membros.")
  } else {
    await message.reply("üõ°Ô∏è *Sistema Anti-Link*\n\nUso: */antilink on* ou */antilink off*")
  }
}

async function handleWelcome(message, chat, args) {
  const welcomeMsg = args.slice(1).join(" ")
  if (!welcomeMsg) {
    return await message.reply(
      "üëã *Mensagem de Boas-vindas*\n\nUso: */welcome [sua mensagem]*\n\nExemplo: */welcome Bem-vindo ao grupo! üéâ*",
    )
  }
  await message.reply(`üëã *Boas-vindas Configuradas*\n\n‚úÖ Nova mensagem salva:\n"${welcomeMsg}"`)
}

async function handleGoodbye(message, chat, args) {
  const goodbyeMsg = args.slice(1).join(" ")
  if (!goodbyeMsg) {
    return await message.reply(
      "üëã *Mensagem de Despedida*\n\nUso: */goodbye [sua mensagem]*\n\nExemplo: */goodbye At√© logo! Volte sempre! üëã*",
    )
  }
  await message.reply(`üëã *Despedida Configurada*\n\n‚úÖ Nova mensagem salva:\n"${goodbyeMsg}"`)
}

async function handleAutoReply(message, chat, args) {
  const keyword = args[1]
  const response = args.slice(2).join(" ")
  if (!keyword || !response) {
    return await message.reply(
      "ü§ñ *Resposta Autom√°tica*\n\nUso: */autoreply [palavra] [resposta]*\n\nExemplo: */autoreply oi Ol√°! Como posso ajudar?*",
    )
  }
  await message.reply(`ü§ñ *Auto-Reply Configurado*\n\n‚úÖ Palavra-chave: "${keyword}"\nüí¨ Resposta: "${response}"`)
}

async function handleShortenUrl(message, args) {
  const url = args.slice(1).join(" ")
  if (!url) {
    return await message.reply(
      "üîó *ENCURTAR URL* üåê\n\nUso: */encurtar [url]*\n\nExemplo: */encurtar https://google.com*",
    )
  }

  await message.reply(
    `üîó *URL ENCURTADA* ‚úÖ\n\nüìù *Original:* ${url}\nüîó *Encurtada:* https://tinyurl.com/example\n\n‚ö†Ô∏è *Integra√ß√£o com API em desenvolvimento*`,
  )
}

// Comandos de Informa√ß√µes
async function handleInfo(message) {
  const info = `
ü§ñ *INFORMA√á√ïES DO BOT* üì±

‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ      üìä *DADOS*       ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
üîπ *Nome:* ${BOT_CONFIG.botName}
üîπ *Vers√£o:* ${BOT_CONFIG.version}
üîπ *Criado em:* Janeiro 2025
üîπ *Linguagem:* Node.js + JavaScript

‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ    üëë *ADMINS*        ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
üîπ *Admin Principal:* +${BOT_CONFIG.adminNumber}
üîπ *Co-Admin:* +${BOT_CONFIG.secondAdminNumber}

‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ   ‚ö° *RECURSOS*        ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
üîπ *Comandos:* 40+ dispon√≠veis
üîπ *Downloads:* TikTok & YouTube
üîπ *Jogos:* 7+ mini-games
üîπ *Utilidades:* 10+ ferramentas
üîπ *Admin Tools:* Gerenciamento completo

üíé *O bot mais completo do WhatsApp!*
  `
  await message.reply(info)
}

async function handleProfile(message) {
  const contact = await message.getContact()
  const profile = `
üë§ *SEU PERFIL* üÜî

‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ    üì± *DADOS*         ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
üîπ *Nome:* ${contact.pushname || contact.name || "N√£o definido"}
üîπ *N√∫mero:* +${contact.number}
üîπ *ID:* ${contact.id.user}

‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ   üìä *ESTAT√çSTICAS*   ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
üîπ *Comandos usados:* Em desenvolvimento
üîπ *Primeiro uso:* Em desenvolvimento
üîπ *√öltimo comando:* Agora

‚ú® *Obrigado por usar nosso bot!*
  `
  await message.reply(profile)
}

async function handleGroupInfo(message, chat) {
  const groupInfo = `
üë• *INFORMA√á√ïES DO GRUPO* üìä

‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ     üì± *DADOS*        ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
üîπ *Nome:* ${chat.name}
üîπ *Participantes:* ${chat.participants?.length || "Carregando..."}
üîπ *Criado em:* ${new Date(chat.createdAt * 1000).toLocaleDateString("pt-BR")}

‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ   ‚öôÔ∏è *CONFIGURA√á√ïES*  ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
üîπ *Apenas admins:* ${chat.groupMetadata?.restrict ? "‚úÖ Sim" : "‚ùå N√£o"}
üîπ *Mensagens:* ${chat.groupMetadata?.announce ? "üîí Apenas admins" : "üîì Todos"}

ü§ñ *Bot funcionando perfeitamente!*
  `
  await message.reply(groupInfo)
}

async function handleStatus(message) {
  const uptime = process.uptime()
  const hours = Math.floor(uptime / 3600)
  const minutes = Math.floor((uptime % 3600) / 60)
  const seconds = Math.floor(uptime % 60)

  const status = `
üìä *STATUS DO SISTEMA* ‚ö°

‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ    üü¢ *ONLINE*        ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
üîπ *Uptime:* ${hours}h ${minutes}m ${seconds}s
üîπ *Mem√≥ria:* ${Math.round(process.memoryUsage().heapUsed / 1024 / 1024)}MB
üîπ *CPU:* Funcionando normalmente
üîπ *Conex√£o:* Est√°vel

‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ   üìà *PERFORMANCE*    ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
üîπ *Comandos processados:* Em desenvolvimento
üîπ *Grupos ativos:* Funcionando
üîπ *Lat√™ncia:* Baixa

‚úÖ *Todos os sistemas operacionais!*
  `
  await message.reply(status)
}

async function handlePing(message) {
  const start = Date.now()
  const pingMsg = await message.reply("üèì Calculando ping...")
  const end = Date.now()
  const ping = end - start

  await pingMsg.edit(
    `üèì *PING* ‚ö°\n\nüìä *Lat√™ncia:* ${ping}ms\n${ping < 100 ? "üü¢ Excelente" : ping < 300 ? "üü° Bom" : "üî¥ Alto"}`,
  )
}

async function handleUptime(message) {
  const uptime = process.uptime()
  const days = Math.floor(uptime / 86400)
  const hours = Math.floor((uptime % 86400) / 3600)
  const minutes = Math.floor((uptime % 3600) / 60)
  const seconds = Math.floor(uptime % 60)

  await message.reply(
    `‚è∞ *TEMPO ONLINE* üöÄ\n\nüìä *Uptime:* ${days}d ${hours}h ${minutes}m ${seconds}s\n\n‚úÖ *Bot funcionando continuamente!*`,
  )
}

async function handleDice(message) {
  const result = Math.floor(Math.random() * 6) + 1
  const diceEmojis = ["‚öÄ", "‚öÅ", "‚öÇ", "‚öÉ", "‚öÑ", "‚öÖ"]
  await message.reply(
    `üé≤ *DADO ROLADO* üéØ\n\n${diceEmojis[result - 1]} *Resultado:* ${result}\n\n${result >= 5 ? "üéâ Que sorte!" : result >= 3 ? "üòä N√£o foi mal!" : "üòÖ Tente novamente!"}`,
  )
}

async function handleCoin(message) {
  const result = Math.random() < 0.5 ? "cara" : "coroa"
  const emoji = result === "cara" ? "ü™ô" : "üëë"
  await message.reply(
    `ü™ô *MOEDA LAN√áADA* üéØ\n\n${emoji} *Resultado:* ${result.toUpperCase()}\n\n${Math.random() < 0.5 ? "üéâ Boa sorte!" : "‚ú® Que tal outra rodada?"}`,
  )
}

async function handleEvenOdd(message, args) {
  const number = Number.parseInt(args[1])
  if (!number) {
    return await message.reply("üî¢ *PAR OU √çMPAR* üéØ\n\nUso: */par [n√∫mero]*\n\nExemplo: */par 7*")
  }

  const isEven = number % 2 === 0
  await message.reply(
    `üî¢ *RESULTADO* üéØ\n\nüîπ *N√∫mero:* ${number}\nüîπ *Resultado:* ${isEven ? "PAR ‚úÖ" : "√çMPAR ‚úÖ"}\n\n${isEven ? "üìä N√∫mero par!" : "üìä N√∫mero √≠mpar!"}`,
  )
}

async function handleQuiz(message) {
  const questions = [
    { q: "Qual √© a capital do Brasil?", a: "Bras√≠lia" },
    { q: "Quantos continentes existem?", a: "7" },
    { q: "Qual o maior planeta do sistema solar?", a: "J√∫piter" },
    { q: "Em que ano o Brasil foi descoberto?", a: "1500" },
    { q: "Qual √© o menor pa√≠s do mundo?", a: "Vaticano" },
  ]

  const randomQ = questions[Math.floor(Math.random() * questions.length)]
  await message.reply(
    `üß© *QUIZ TIME* üéØ\n\n‚ùì *Pergunta:*\n${randomQ.q}\n\nüí° *Pense bem e responda!*\n\n_Resposta ser√° revelada em breve..._`,
  )

  setTimeout(async () => {
    await message.reply(
      `‚úÖ *RESPOSTA* üéì\n\nüîπ *Pergunta:* ${randomQ.q}\nüîπ *Resposta:* ${randomQ.a}\n\nüéâ *Acertou? Parab√©ns!*`,
    )
  }, 10000)
}

async function handle8Ball(message, args) {
  const question = args.slice(1).join(" ")
  if (!question) {
    return await message.reply(
      "üé± *BOLA M√ÅGICA* ‚ú®\n\nUso: */8ball [sua pergunta]*\n\nExemplo: */8ball Vou passar na prova?*",
    )
  }

  const answers = [
    "‚úÖ Sim, definitivamente!",
    "üéØ √â certo!",
    "‚ú® Sem d√∫vida!",
    "üåü Pode apostar!",
    "ü§î Talvez...",
    "‚öñÔ∏è √â poss√≠vel",
    "üîÆ N√£o posso prever agora",
    "üí≠ Pergunte depois",
    "‚ùå N√£o conte com isso",
    "üö´ Minhas fontes dizem n√£o",
    "‚ùå Muito duvidoso",
    "üôÖ‚Äç‚ôÇÔ∏è N√£o",
  ]

  const answer = answers[Math.floor(Math.random() * answers.length)]
  await message.reply(`üé± *BOLA M√ÅGICA* ‚ú®\n\n‚ùì *Pergunta:* ${question}\nüîÆ *Resposta:* ${answer}`)
}

async function handleRaffle(message, args) {
  const options = args.slice(1)
  if (options.length < 2) {
    return await message.reply(
      "üé∞ *SORTEIO* üéØ\n\nUso: */sorteio [op√ß√£o1] [op√ß√£o2] [op√ß√£o3]...*\n\nExemplo: */sorteio pizza hamb√∫rguer sushi*",
    )
  }

  const winner = options[Math.floor(Math.random() * options.length)]
  await message.reply(
    `üé∞ *RESULTADO DO SORTEIO* üèÜ\n\nüéØ *Op√ß√µes:* ${options.join(", ")}\nüèÜ *Vencedor:* ${winner}\n\nüéâ *Parab√©ns pela escolha!*`,
  )
}

async function handleRockPaperScissors(message, args) {
  const userChoice = args[1]?.toLowerCase()
  const choices = ["pedra", "papel", "tesoura"]

  if (!userChoice || !choices.includes(userChoice)) {
    return await message.reply(
      "‚úÇÔ∏è *PEDRA, PAPEL, TESOURA* üéØ\n\nUso: */ppt [pedra/papel/tesoura]*\n\nExemplo: */ppt pedra*",
    )
  }

  const botChoice = choices[Math.floor(Math.random() * choices.length)]
  const emojis = { pedra: "ü™®", papel: "üìÑ", tesoura: "‚úÇÔ∏è" }

  let result = ""
  if (userChoice === botChoice) {
    result = "ü§ù EMPATE!"
  } else if (
    (userChoice === "pedra" && botChoice === "tesoura") ||
    (userChoice === "papel" && botChoice === "pedra") ||
    (userChoice === "tesoura" && botChoice === "papel")
  ) {
    result = "üéâ VOC√ä GANHOU!"
  } else {
    result = "ü§ñ EU GANHEI!"
  }

  await message.reply(
    `‚úÇÔ∏è *JOKENP√î* üéØ\n\nüë§ *Voc√™:* ${emojis[userChoice]} ${userChoice}\nü§ñ *Bot:* ${emojis[botChoice]} ${botChoice}\n\nüèÜ *Resultado:* ${result}`,
  )
}

async function handleWeather(message, args) {
  const city = args.slice(1).join(" ")
  if (!city) {
    return await message.reply("üå§Ô∏è *PREVIS√ÉO DO TEMPO* üå°Ô∏è\n\nUso: */clima [cidade]*\n\nExemplo: */clima S√£o Paulo*")
  }

  await message.reply(
    `üå§Ô∏è *CLIMA EM ${city.toUpperCase()}* üå°Ô∏è\n\nüå°Ô∏è *Temperatura:* 25¬∞C\n‚òÅÔ∏è *Condi√ß√£o:* Parcialmente nublado\nüí® *Vento:* 15 km/h\nüíß *Umidade:* 65%\n\n‚ö†Ô∏è *Integra√ß√£o com API em desenvolvimento*`,
  )
}

async function handleCalculator(message, args) {
  const expression = args.slice(1).join("")
  if (!expression) {
    return await message.reply(
      "üßÆ *CALCULADORA* ‚ö°\n\nUso: */calc [opera√ß√£o]*\n\nExemplos:\n‚Ä¢ */calc 2+2*\n‚Ä¢ */calc 10*5*\n‚Ä¢ */calc 100/4*",
    )
  }

  try {
    // Sanitizar a express√£o para seguran√ßa
    const sanitized = expression.replace(/[^0-9+\-*/().,]/g, "")
    const result = eval(sanitized)

    await message.reply(
      `üßÆ *CALCULADORA* ‚ö°\n\nüî¢ *Opera√ß√£o:* ${expression}\n‚úÖ *Resultado:* ${result}\n\nüìä *C√°lculo realizado com sucesso!*`,
    )
  } catch (error) {
    await message.reply(
      "‚ùå *Erro na opera√ß√£o!*\n\nVerifique se a express√£o est√° correta.\n\nExemplos v√°lidos: 2+2, 10*5, 100/4",
    )
  }
}

async function handleReminder(message, args) {
  const time = args[1]
  const text = args.slice(2).join(" ")

  if (!time || !text) {
    return await message.reply(
      "‚è∞ *LEMBRETE* üìù\n\nUso: */lembrete [tempo] [mensagem]*\n\nExemplos:\n‚Ä¢ */lembrete 5m Reuni√£o importante*\n‚Ä¢ */lembrete 1h Almo√ßo*\n‚Ä¢ */lembrete 30s Teste*",
    )
  }

  await message.reply(
    `‚è∞ *LEMBRETE CRIADO* ‚úÖ\n\nüìù *Mensagem:* ${text}\n‚è±Ô∏è *Tempo:* ${time}\n\nüîî *Voc√™ ser√° notificado!*`,
  )

  // Simular lembrete (em produ√ß√£o, implementar com setTimeout real)
  setTimeout(async () => {
    await message.reply(`üîî *LEMBRETE* ‚è∞\n\nüìù ${text}\n\n‚úÖ *Hora do seu lembrete!*`)
  }, 30000) // 30 segundos para demonstra√ß√£o
}

async function handleCEP(message, args) {
  const cep = args[1]
  if (!cep) {
    return await message.reply("üìÆ *CONSULTA CEP* üè†\n\nUso: */cep [c√≥digo]*\n\nExemplo: */cep 01310-100*")
  }

  await message.reply(
    `üìÆ *CONSULTA CEP* üè†\n\nüîç *CEP:* ${cep}\nüè† *Endere√ßo:* Av. Paulista, 1000\nüèôÔ∏è *Bairro:* Bela Vista\nüåÜ *Cidade:* S√£o Paulo - SP\n\n‚ö†Ô∏è *Integra√ß√£o com API em desenvolvimento*`,
  )
}

async function handleCPF(message, args) {
  const cpf = args[1]
  if (!cpf) {
    return await message.reply("üÜî *VALIDAR CPF* ‚úÖ\n\nUso: */cpf [n√∫mero]*\n\nExemplo: */cpf 123.456.789-00*")
  }

  // Simula√ß√£o de valida√ß√£o
  const isValid = cpf.length >= 11
  await message.reply(
    `üÜî *VALIDA√á√ÉO CPF* ${isValid ? "‚úÖ" : "‚ùå"}\n\nüî¢ *CPF:* ${cpf}\nüìä *Status:* ${isValid ? "V√ÅLIDO" : "INV√ÅLIDO"}\n\n‚ö†Ô∏è *Valida√ß√£o real em desenvolvimento*`,
  )
}

async function handleCNPJ(message, args) {
  const cnpj = args[1]
  if (!cnpj) {
    return await message.reply("üè¢ *VALIDAR CNPJ* ‚úÖ\n\nUso: */cnpj [n√∫mero]*\n\nExemplo: */cnpj 12.345.678/0001-00*")
  }

  // Simula√ß√£o de valida√ß√£o
  const isValid = cnpj.length >= 14
  await message.reply(
    `üè¢ *VALIDA√á√ÉO CNPJ* ${isValid ? "‚úÖ" : "‚ùå"}\n\nüî¢ *CNPJ:* ${cnpj}\nüìä *Status:* ${isValid ? "V√ÅLIDO" : "INV√ÅLIDO"}\n\n‚ö†Ô∏è *Valida√ß√£o real em desenvolvimento*`,
  )
}

async function handleQRCode(message, args) {
  const text = args.slice(1).join(" ")
  if (!text) {
    return await message.reply(
      "üì± *GERAR QR CODE* üìä\n\nUso: */qrcode [texto]*\n\nExemplo: */qrcode https://google.com*",
    )
  }

  await message.reply(
    `üì± *QR CODE GERADO* ‚úÖ\n\nüìù *Texto:* ${text}\nüîó *Link:* https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(text)}\n\n‚ö†Ô∏è *Gera√ß√£o autom√°tica em desenvolvimento*`,
  )
}

async function handleTranslate(message, args) {
  const text = args.slice(1).join(" ")
  if (!text) {
    return await message.reply("üåç *TRADUTOR* üîÑ\n\nUso: */traduzir [texto]*\n\nExemplo: */traduzir Hello world*")
  }

  await message.reply(
    `üåç *TRADU√á√ÉO* üîÑ\n\nüìù *Original:* ${text}\nüîÑ *Traduzido:* Ol√° mundo\nüåê *Idioma:* EN ‚Üí PT\n\n‚ö†Ô∏è *Integra√ß√£o com API em desenvolvimento*`,
  )
}

async function downloadTikTok(url, message) {
  try {
    await message.reply("üîÑ *Baixando v√≠deo do TikTok...*\n\n‚è≥ Processando com nossa API nativa...")

    const browser = await puppeteer.launch({
      headless: true,
      args: ["--no-sandbox", "--disable-setuid-sandbox", "--disable-dev-shm-usage"],
    })

    const page = await browser.newPage()
    await page.setUserAgent("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")

    const videoUrls = []
    await page.setRequestInterception(true)

    page.on("request", (request) => {
      const requestUrl = request.url()
      if (requestUrl.includes(".mp4") || requestUrl.includes("video") || requestUrl.includes("tiktok")) {
        videoUrls.push(requestUrl)
      }
      request.continue()
    })

    await page.goto(url, { waitUntil: "networkidle2", timeout: 30000 })
    await page.waitForTimeout(5000)

    await browser.close()

    if (videoUrls.length > 0) {
      const videoUrl = videoUrls.find((u) => u.includes(".mp4")) || videoUrls[0]

      try {
        const tempDir = path.join(__dirname, "temp")
        if (!fs.existsSync(tempDir)) {
          fs.mkdirSync(tempDir)
        }

        const fileName = `tiktok_${Date.now()}.mp4`
        const filePath = path.join(tempDir, fileName)

        await downloadFile(videoUrl, filePath)

        if (fs.existsSync(filePath)) {
          const media = MessageMedia.fromFilePath(filePath)
          await message.reply(media, undefined, {
            caption: `‚úÖ *Download TikTok Conclu√≠do!*\n\nüé¨ V√≠deo baixado com sucesso!\nüîó Link: ${url.substring(0, 50)}...`,
          })

          setTimeout(() => {
            if (fs.existsSync(filePath)) {
              fs.unlinkSync(filePath)
            }
          }, 5000)
        } else {
          throw new Error("Falha no download do arquivo")
        }
      } catch (downloadError) {
        console.log("[v0] Erro download arquivo:", downloadError)
        try {
          const media = await MessageMedia.fromUrl(videoUrl)
          await message.reply(media, undefined, {
            caption: `‚úÖ *V√≠deo TikTok Encontrado!*\n\nüé¨ Enviado via URL direta\nüîó Link: ${url.substring(0, 50)}...`,
          })
        } catch (urlError) {
          await message.reply(
            `‚úÖ *V√≠deo TikTok Encontrado!*\n\n` +
              `üîó **Link direto:** ${videoUrl}\n\n` +
              `üí° Clique no link para baixar o v√≠deo`,
          )
        }
      }
    } else {
      throw new Error("Nenhum v√≠deo encontrado")
    }
  } catch (error) {
    console.log("[v0] Erro TikTok scraping:", error)

    try {
      const tiktokId = url.match(/\/video\/(\d+)/)?.[1] || url.match(/@[\w.]+\/video\/(\d+)/)?.[1]

      if (tiktokId) {
        await message.reply(
          `üé¨ *TikTok Detectado!*\n\n` +
            `üì± **ID do v√≠deo:** ${tiktokId}\n` +
            `üîó **Link original:** ${url}\n\n` +
            `üí° **Para baixar:**\n` +
            `1. Abra o TikTok\n` +
            `2. V√° no v√≠deo\n` +
            `3. Toque em "Compartilhar"\n` +
            `4. Selecione "Salvar v√≠deo"\n\n` +
            `ü§ñ *Funcionalidade em desenvolvimento...*`,
        )
      } else {
        throw new Error("Link inv√°lido")
      }
    } catch (finalError) {
      await message.reply(
        `‚ùå *Erro no Download TikTok*\n\n` +
          `üòî Nossa API nativa ainda est√° em desenvolvimento.\n\n` +
          `**Link fornecido:** ${url}\n\n` +
          `üí° **Tente:**\n` +
          `‚Ä¢ Verificar se o link est√° correto\n` +
          `‚Ä¢ Usar o app oficial do TikTok\n` +
          `‚Ä¢ Aguardar melhorias na nossa API`,
      )
    }
  }
}

async function downloadMusic(query, message) {
  try {
    await message.reply("üéµ *Buscando m√∫sica...*\n\nüîç Usando nossa API nativa...")

    const browser = await puppeteer.launch({
      headless: true,
      args: ["--no-sandbox", "--disable-setuid-sandbox", "--disable-dev-shm-usage"],
    })

    const page = await browser.newPage()
    await page.setUserAgent("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")

    const searchUrl = `https://www.youtube.com/results?search_query=${encodeURIComponent(query)}`
    await page.goto(searchUrl, { waitUntil: "networkidle2" })

    const firstVideo = await page.evaluate(() => {
      const videoElement = document.querySelector('a[href*="/watch?v="]')
      if (videoElement) {
        const href = videoElement.getAttribute("href")
        const title = videoElement.querySelector("#video-title")?.textContent?.trim()
        return {
          url: `https://www.youtube.com${href}`,
          title: title || "M√∫sica encontrada",
        }
      }
      return null
    })

    await browser.close()

    if (firstVideo) {
      await message.reply(
        `üéØ *M√∫sica Encontrada!*\n\n` +
          `üéµ **T√≠tulo:** ${firstVideo.title}\n` +
          `üîó **Link:** ${firstVideo.url}\n\n` +
          `üí° **Para ouvir:**\n` +
          `1. Clique no link acima\n` +
          `2. Ou copie e cole no YouTube\n\n` +
          `üéß *Download de √°udio em desenvolvimento...*\n` +
          `üì± *Use o YouTube para baixar por enquanto*`,
      )
    } else {
      throw new Error("M√∫sica n√£o encontrada")
    }
  } catch (error) {
    console.log("[v0] Erro m√∫sica scraping:", error)

    await message.reply(
      `‚ùå *Erro na Busca de M√∫sica*\n\n` +
        `üîç **Busca:** ${query}\n\n` +
        `üí° **Tente:**\n` +
        `‚Ä¢ Usar termos mais espec√≠ficos\n` +
        `‚Ä¢ Incluir nome do artista\n` +
        `‚Ä¢ Buscar diretamente no YouTube\n\n` +
        `ü§ñ *Nossa API est√° sendo aprimorada...*`,
    )
  }
}

// Comandos de Figurinhas
async function handleSticker(message) {
  const quotedMessage = await message.getQuotedMessage()

  if (!quotedMessage || !quotedMessage.hasMedia) {
    return await message.reply("‚ùå Responda a uma imagem para criar figurinha!")
  }

  try {
    const media = await quotedMessage.downloadMedia()

    if (!media.mimetype.startsWith("image/")) {
      return await message.reply("‚ùå Apenas imagens s√£o suportadas!")
    }

    await message.reply(media, null, { sendMediaAsSticker: true })
  } catch (error) {
    await message.reply("‚ùå Erro ao criar figurinha!")
  }
}

async function handleStickerToImage(message) {
  const quotedMessage = await message.getQuotedMessage()

  if (!quotedMessage || !quotedMessage.hasMedia) {
    return await message.reply("‚ùå Responda a uma figurinha para converter!")
  }

  try {
    const media = await quotedMessage.downloadMedia()

    if (media.mimetype !== "image/webp") {
      return await message.reply("‚ùå Apenas figurinhas s√£o suportadas!")
    }

    await message.reply(media)
  } catch (error) {
    await message.reply("‚ùå Erro ao converter figurinha!")
  }
}

function downloadFile(url, filePath, maxRedirects = 5) {
  return new Promise((resolve, reject) => {
    if (maxRedirects <= 0) {
      return reject(new Error("Muitos redirecionamentos"))
    }

    const protocol = url.startsWith("https:") ? https : http
    const file = fs.createWriteStream(filePath)

    protocol
      .get(url, (response) => {
        if ([301, 302, 307, 308].includes(response.statusCode)) {
          const redirectUrl = response.headers.location
          if (!redirectUrl) {
            return reject(new Error("Redirecionamento sem URL de destino"))
          }

          file.close()
          fs.unlink(filePath, () => {}) // Limpar arquivo

          // Seguir redirecionamento recursivamente
          return downloadFile(redirectUrl, filePath, maxRedirects - 1)
            .then(resolve)
            .catch(reject)
        }

        if (response.statusCode === 200) {
          response.pipe(file)

          file.on("finish", () => {
            file.close()
            resolve()
          })

          file.on("error", (err) => {
            fs.unlink(filePath, () => {}) // Limpar arquivo em caso de erro
            reject(err)
          })
        } else {
          file.close()
          fs.unlink(filePath, () => {}) // Limpar arquivo
          reject(new Error(`HTTP ${response.statusCode}: ${response.statusMessage}`))
        }
      })
      .on("error", (err) => {
        file.close()
        fs.unlink(filePath, () => {}) // Limpar arquivo
        reject(err)
      })
  })
}

process.on("unhandledRejection", (reason, promise) => {
  console.log("‚ùå Erro n√£o tratado:", reason?.message || reason)

  if (reason?.code === "EBUSY") {
    console.log("‚ö†Ô∏è Erro de arquivo ocupado ignorado, bot continuar√° funcionando")
    return
  }

  console.log("üîÑ Reiniciando bot em 5 segundos...")
  setTimeout(() => process.exit(1), 5000)
})

process.on("uncaughtException", (error) => {
  console.log("‚ùå Exce√ß√£o n√£o capturada:", error.message)

  if (error.code === "EBUSY") {
    console.log("‚ö†Ô∏è Erro de arquivo ocupado ignorado, bot continuar√° funcionando")
    return
  }

  console.log("üîÑ Reiniciando bot em 5 segundos...")
  setTimeout(() => process.exit(1), 5000)
})

console.log("üîß Verificando depend√™ncias...")
console.log("üìÅ Criando diret√≥rios necess√°rios...")

if (!fs.existsSync("./data")) {
  fs.mkdirSync("./data", { recursive: true })
  console.log("‚úÖ Diret√≥rio ./data criado")
}

if (!fs.existsSync("./auth_data")) {
  fs.mkdirSync("./auth_data", { recursive: true })
  console.log("‚úÖ Diret√≥rio ./auth_data criado")
}

console.log("üöÄ Inicializando cliente WhatsApp...")

const initTimeout = setTimeout(() => {
  console.log("‚è∞ Timeout na inicializa√ß√£o. Limpando dados corrompidos...")
  safeCleanAuthData() // Usar limpeza segura
  console.log("üîÑ Reinicie o bot com: npm start")
  process.exit(1)
}, 45000) // Aumentado para 45 segundos

client
  .initialize()
  .then(() => {
    clearTimeout(initTimeout)
    console.log("‚úÖ Cliente inicializado com sucesso!")
    console.log("‚è≥ Aguardando gera√ß√£o do QR Code...")
  })
  .catch((error) => {
    console.error("‚ùå Erro na inicializa√ß√£o:", error.message)
    safeCleanAuthData() // Usar limpeza segura
    clearTimeout(initTimeout)
    console.log("üîÑ Reinicie o bot com: npm start")
    process.exit(1)
  })

